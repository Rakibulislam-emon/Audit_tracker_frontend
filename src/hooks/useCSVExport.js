// src/hooks/useCSVExport.js

import { useState } from "react";

/**
 * Custom hook for CSV export functionality
 * Enhanced to support both generic table data and report-specific exports
 */
export const useCSVExport = () => {
  const [isExporting, setIsExporting] = useState(false);

  /**
   * Converts an array of objects to CSV format and triggers download
   * @param {Array} data - Array of objects to export
   * @param {String} filename - Name of the file to download (without extension)
   * @param {Object} headers - Optional mapping of keys to display names { key: "Display Name" }
   */
  const exportToCSV = (data, filename = "export", headers = null) => {
    if (!data || !data.length) {
      console.warn("No data to export");
      return;
    }

    try {
      setIsExporting(true);

      // 1. Determine columns
      const columns = headers ? Object.keys(headers) : Object.keys(data[0]);

      // 2. Create CSV Header Row
      const headerRow = headers
        ? columns.map((col) => `"${headers[col]}"`).join(",")
        : columns.map((col) => `"${col}"`).join(",");

      // 3. Create CSV Data Rows
      const rows = data.map((row) => {
        return columns
          .map((col) => {
            let cell =
              row[col] === null || row[col] === undefined ? "" : row[col];

            // Handle objects (like nested user objects)
            if (typeof cell === "object") {
              cell = JSON.stringify(cell);
            }

            // Escape quotes and wrap in quotes
            cell = cell.toString().replace(/"/g, '""');
            return `"${cell}"`;
          })
          .join(",");
      });

      // 4. Combine Header and Rows
      const csvContent = [headerRow, ...rows].join("\n");

      // 5. Add UTF-8 BOM for Excel compatibility
      const BOM = "\uFEFF";

      // 6. Create Blob and Download Link
      const blob = new Blob([BOM + csvContent], {
        type: "text/csv;charset=utf-8;",
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");

      link.setAttribute("href", url);
      link.setAttribute("download", `${filename}.csv`);
      link.style.visibility = "hidden";

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error("CSV export error:", error);
    } finally {
      setIsExporting(false);
    }
  };

  /**
   * Export report data to CSV (report-specific format)
   * The CSV structure mimics the professional Excel report with sections separated by blank lines.
   * @param {Object} reportData - The report object from backend
   * @param {String} filename - Custom filename (optional)
   */
  const exportReportToCSV = (reportData, filename) => {
    if (!reportData) {
      console.error("No report data provided");
      return;
    }

    try {
      setIsExporting(true);

      const lines = [];

      // --- 1. Report Summary ---
      lines.push("AUDIT REPORT SUMMARY");
      lines.push(`Title,${escapeCsvValue(reportData.title || "")}`);
      lines.push(`Description,${escapeCsvValue(reportData.description || "")}`);
      lines.push(`Type,${escapeCsvValue(reportData.reportType || "")}`);
      lines.push(`Status,${escapeCsvValue(reportData.reportStatus || "")}`);
      lines.push(
        `Generated At,${escapeCsvValue(
          reportData.generatedAt
            ? new Date(reportData.generatedAt).toLocaleString()
            : ""
        )}`
      );
      lines.push(
        `Generated By,${escapeCsvValue(reportData.generatedBy?.name || "")}`
      );
      lines.push(
        `Overall Risk Rating,${escapeCsvValue(
          (reportData.metrics?.overallRiskRating || "N/A").toUpperCase()
        )}`
      );
      lines.push("");

      // --- 2. Executive Summary ---
      lines.push("EXECUTIVE SUMMARY");
      lines.push(
        `${escapeCsvValue(
          reportData.executiveSummary || "No summary available"
        )}`
      );
      lines.push("");

      // --- 3. Site Information ---
      if (reportData.auditSession) {
        const session = reportData.auditSession;
        lines.push("SITE INFORMATION");
        lines.push(`Audit Session,${escapeCsvValue(session.title || "")}`);
        lines.push(`Site Name,${escapeCsvValue(session.site?.name || "")}`);
        lines.push(`Location,${escapeCsvValue(session.site?.location || "")}`);
        lines.push(`Company,${escapeCsvValue(session.company?.name || "")}`);
        lines.push(`Template,${escapeCsvValue(session.template?.title || "")}`);
        lines.push(
          `Scheduled Date,${escapeCsvValue(
            session.scheduledDate
              ? new Date(session.scheduledDate).toLocaleDateString()
              : ""
          )}`
        );
        lines.push("");
      }

      // --- 4. Risk Analysis ---
      lines.push("RISK ANALYSIS");
      lines.push("Risk Level,Count,Percentage");

      const metrics = reportData.metrics || {};
      const total = metrics.totalProblems || 1;
      const risks = [
        ["Critical", metrics.criticalProblems || 0],
        ["High", metrics.highRiskProblems || 0],
        ["Medium", metrics.mediumRiskProblems || 0],
        ["Low", metrics.lowRiskProblems || 0],
      ];

      risks.forEach(([level, count]) => {
        const pct = ((count / total) * 100).toFixed(1) + "%";
        lines.push(`${level},${count},${pct}`);
      });
      lines.push(`TOTAL,${metrics.totalProblems || 0},100%`);
      lines.push("");

      // --- 5. Detailed Findings ---
      if (reportData.findings && reportData.findings.length > 0) {
        lines.push("DETAILED FINDINGS");
        lines.push("#,Risk Level,Description,Recommendation,Problem ID");

        reportData.findings.forEach((finding, index) => {
          lines.push(
            [
              index + 1,
              (finding.riskLevel || "medium").toUpperCase(),
              escapeCsvValue(finding.description || ""),
              escapeCsvValue(finding.recommendation || ""),
              escapeCsvValue(finding.problem?._id || finding.problem || "N/A"),
            ].join(",")
          );
        });
      } else {
        lines.push("No findings recorded.");
      }

      // Generate File
      const csvContent = lines.join("\n");
      const BOM = "\uFEFF";
      const blob = new Blob([BOM + csvContent], {
        type: "text/csv;charset=utf-8;",
      });

      const finalFilename =
        filename ||
        `${reportData.title?.replace(/[^a-z0-9]/gi, "_")}_report.csv`;

      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.setAttribute("href", url);
      link.setAttribute("download", finalFilename);
      link.style.visibility = "hidden";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error("Report CSV export error:", error);
    } finally {
      setIsExporting(false);
    }
  };

  return { exportToCSV, exportReportToCSV, isExporting };
};

/**
 * Escape special characters for CSV
 */
function escapeCsvValue(value) {
  if (value === null || value === undefined) return "";
  const stringValue = String(value);
  if (
    stringValue.includes(",") ||
    stringValue.includes('"') ||
    stringValue.includes("\n")
  ) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }
  return stringValue;
}

export default useCSVExport;
